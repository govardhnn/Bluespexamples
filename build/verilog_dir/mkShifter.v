//
// Generated by Bluespec Compiler, version 2023.01-23-g764b7230 (build 764b7230)
//
// On Wed Sep  6 10:38:53 IST 2023
//
//
// Ports:
// Name                         I/O  size props
// RDY_do_shift                   O     1
// get_rsp                        O     8 reg
// RDY_get_rsp                    O     1
// CLK                            I     1 clock
// RST_N                          I     1 reset
// do_shift_data                  I     8
// do_shift_amt                   I     3
// EN_do_shift                    I     1
// EN_get_rsp                     I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkShifter(CLK,
		 RST_N,

		 do_shift_data,
		 do_shift_amt,
		 EN_do_shift,
		 RDY_do_shift,

		 EN_get_rsp,
		 get_rsp,
		 RDY_get_rsp);
  input  CLK;
  input  RST_N;

  // action method do_shift
  input  [7 : 0] do_shift_data;
  input  [2 : 0] do_shift_amt;
  input  EN_do_shift;
  output RDY_do_shift;

  // actionvalue method get_rsp
  input  EN_get_rsp;
  output [7 : 0] get_rsp;
  output RDY_get_rsp;

  // signals for module outputs
  wire [7 : 0] get_rsp;
  wire RDY_do_shift, RDY_get_rsp;

  // register reg_amt
  reg [2 : 0] reg_amt;
  wire [2 : 0] reg_amt$D_IN;
  wire reg_amt$EN;

  // register reg_data
  reg [7 : 0] reg_data;
  reg [7 : 0] reg_data$D_IN;
  wire reg_data$EN;

  // register reg_state
  reg [1 : 0] reg_state;
  reg [1 : 0] reg_state$D_IN;
  wire reg_state$EN;

  // rule scheduling signals
  wire CAN_FIRE_RL_rl_2,
       CAN_FIRE_RL_rl_3,
       CAN_FIRE_do_shift,
       CAN_FIRE_get_rsp,
       WILL_FIRE_RL_rl_2,
       WILL_FIRE_RL_rl_3,
       WILL_FIRE_do_shift,
       WILL_FIRE_get_rsp;

  // inputs to muxes for submodule ports
  wire [7 : 0] MUX_reg_data$write_1__VAL_1,
	       MUX_reg_data$write_1__VAL_2,
	       MUX_reg_data$write_1__VAL_3;

  // action method do_shift
  assign RDY_do_shift = reg_state == 2'd0 ;
  assign CAN_FIRE_do_shift = reg_state == 2'd0 ;
  assign WILL_FIRE_do_shift = EN_do_shift ;

  // actionvalue method get_rsp
  assign get_rsp = reg_data ;
  assign RDY_get_rsp = reg_state == 2'd3 ;
  assign CAN_FIRE_get_rsp = reg_state == 2'd3 ;
  assign WILL_FIRE_get_rsp = EN_get_rsp ;

  // rule RL_rl_2
  assign CAN_FIRE_RL_rl_2 = reg_state == 2'd1 ;
  assign WILL_FIRE_RL_rl_2 = CAN_FIRE_RL_rl_2 ;

  // rule RL_rl_3
  assign CAN_FIRE_RL_rl_3 = reg_state == 2'd2 ;
  assign WILL_FIRE_RL_rl_3 = CAN_FIRE_RL_rl_3 ;

  // inputs to muxes for submodule ports
  assign MUX_reg_data$write_1__VAL_1 =
	     reg_amt[1] ? { reg_data[5:0], 2'd0 } : reg_data ;
  assign MUX_reg_data$write_1__VAL_2 =
	     reg_amt[2] ? { reg_data[3:0], 4'd0 } : reg_data ;
  assign MUX_reg_data$write_1__VAL_3 =
	     do_shift_amt[0] ? { do_shift_data[6:0], 1'd0 } : do_shift_data ;

  // register reg_amt
  assign reg_amt$D_IN = do_shift_amt ;
  assign reg_amt$EN = EN_do_shift ;

  // register reg_data
  always@(WILL_FIRE_RL_rl_2 or
	  MUX_reg_data$write_1__VAL_1 or
	  WILL_FIRE_RL_rl_3 or
	  MUX_reg_data$write_1__VAL_2 or
	  EN_do_shift or MUX_reg_data$write_1__VAL_3)
  begin
    case (1'b1) // synopsys parallel_case
      WILL_FIRE_RL_rl_2: reg_data$D_IN = MUX_reg_data$write_1__VAL_1;
      WILL_FIRE_RL_rl_3: reg_data$D_IN = MUX_reg_data$write_1__VAL_2;
      EN_do_shift: reg_data$D_IN = MUX_reg_data$write_1__VAL_3;
      default: reg_data$D_IN = 8'b10101010 /* unspecified value */ ;
    endcase
  end
  assign reg_data$EN = WILL_FIRE_RL_rl_2 || WILL_FIRE_RL_rl_3 || EN_do_shift ;

  // register reg_state
  always@(EN_get_rsp or EN_do_shift or WILL_FIRE_RL_rl_2 or WILL_FIRE_RL_rl_3)
  begin
    case (1'b1) // synopsys parallel_case
      EN_get_rsp: reg_state$D_IN = 2'd0;
      EN_do_shift: reg_state$D_IN = 2'd1;
      WILL_FIRE_RL_rl_2: reg_state$D_IN = 2'd2;
      WILL_FIRE_RL_rl_3: reg_state$D_IN = 2'd3;
      default: reg_state$D_IN = 2'b10 /* unspecified value */ ;
    endcase
  end
  assign reg_state$EN =
	     EN_get_rsp || EN_do_shift || WILL_FIRE_RL_rl_2 ||
	     WILL_FIRE_RL_rl_3 ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        reg_amt <= `BSV_ASSIGNMENT_DELAY 3'd0;
	reg_data <= `BSV_ASSIGNMENT_DELAY 8'd0;
	reg_state <= `BSV_ASSIGNMENT_DELAY 2'd0;
      end
    else
      begin
        if (reg_amt$EN) reg_amt <= `BSV_ASSIGNMENT_DELAY reg_amt$D_IN;
	if (reg_data$EN) reg_data <= `BSV_ASSIGNMENT_DELAY reg_data$D_IN;
	if (reg_state$EN) reg_state <= `BSV_ASSIGNMENT_DELAY reg_state$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    reg_amt = 3'h2;
    reg_data = 8'hAA;
    reg_state = 2'h2;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_get_rsp) $display("%0d from design", reg_data);
  end
  // synopsys translate_on
endmodule  // mkShifter

