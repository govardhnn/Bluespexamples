//
// Generated by Bluespec Compiler, version 2023.01-23-g764b7230 (build 764b7230)
//
// On Fri Sep  1 19:32:09 IST 2023
//
//
// Ports:
// Name                         I/O  size props
// RDY_start_count                O     1 const
// counter_value                  O    32 reg
// RDY_counter_value              O     1 const
// CLK                            I     1 clock
// RST_N                          I     1 reset
// start_count_initial_value      I    32
// EN_start_count                 I     1
// EN_counter_value               I     1 unused
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkCounter(CLK,
		 RST_N,

		 start_count_initial_value,
		 EN_start_count,
		 RDY_start_count,

		 EN_counter_value,
		 counter_value,
		 RDY_counter_value);
  input  CLK;
  input  RST_N;

  // action method start_count
  input  [31 : 0] start_count_initial_value;
  input  EN_start_count;
  output RDY_start_count;

  // actionvalue method counter_value
  input  EN_counter_value;
  output [31 : 0] counter_value;
  output RDY_counter_value;

  // signals for module outputs
  wire [31 : 0] counter_value;
  wire RDY_counter_value, RDY_start_count;

  // register start
  reg start;
  wire start$D_IN, start$EN;

  // register x
  reg [31 : 0] x;
  wire [31 : 0] x$D_IN;
  wire x$EN;

  // rule scheduling signals
  wire WILL_FIRE_RL_count_up;

  // remaining internal signals
  wire [31 : 0] y__h125;
  wire x_ULT_30___d2;

  // action method start_count
  assign RDY_start_count = 1'd1 ;

  // actionvalue method counter_value
  assign counter_value = x ;
  assign RDY_counter_value = 1'd1 ;

  // rule RL_count_up
  assign WILL_FIRE_RL_count_up = x_ULT_30___d2 && start ;

  // register start
  assign start$D_IN = 1'd1 ;
  assign start$EN = EN_start_count ;

  // register x
  assign x$D_IN = EN_start_count ? start_count_initial_value : y__h125 ;
  assign x$EN = EN_start_count || WILL_FIRE_RL_count_up ;

  // remaining internal signals
  assign x_ULT_30___d2 = x < 32'd30 ;
  assign y__h125 = x + 32'd1 ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        start <= `BSV_ASSIGNMENT_DELAY 1'd0;
	x <= `BSV_ASSIGNMENT_DELAY 32'd0;
      end
    else
      begin
        if (start$EN) start <= `BSV_ASSIGNMENT_DELAY start$D_IN;
	if (x$EN) x <= `BSV_ASSIGNMENT_DELAY x$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    start = 1'h0;
    x = 32'hAAAAAAAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_counter_value) $display("counter value: %0d from design", x);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_count_up) $display("x = %0d, y = %0d", x, y__h125);
    if (RST_N != `BSV_RESET_VALUE)
      if (!x_ULT_30___d2) $display("counting has finished at: %0d", x);
    if (RST_N != `BSV_RESET_VALUE) if (!x_ULT_30___d2) $finish(32'd0);
  end
  // synopsys translate_on
endmodule  // mkCounter

